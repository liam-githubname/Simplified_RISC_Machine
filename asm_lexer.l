/* $Id: asm_lexer.l,v 1.26 2023/09/22 20:18:13 leavens Exp leavens $ */
/* Scanner for the SRM Assembly Language */

%option header-file = "asm_lexer.h"
%option outfile = "asm_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"

 /* Tokens generated by Bison */
#include "asm.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
char *filename;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

#undef yywrap   /* sometimes a macro by default */

extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void reg2ast(const char *txt) {
    AST t;
    t.reg.file_loc = file_location_make(filename, yylineno);
    t.reg.type_tag = reg_ast;
    t.reg.text = strdup(yytext);
    unsigned short n;
    sscanf(txt, "%hd", &n);
    t.reg.number = n;
    yylval = t;
}

static void namedreg2ast(unsigned short num, const char *txt) {
    AST t;
    t.reg.file_loc = file_location_make(filename, yylineno);
    t.reg.type_tag = reg_ast;
    t.reg.text = strdup(yytext);
    t.reg.number = num;
    yylval = t;
}


static void ident2ast(const char *name) {
    AST t;
    t.ident.file_loc = file_location_make(filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

static void unsignednum2ast(unsigned int val)
{
    AST t;
    t.unsignednum.file_loc = file_location_make(filename, yylineno);
    t.unsignednum.type_tag = unsignednum_ast;
    t.unsignednum.text = strdup(yytext);
    t.unsignednum.value = val;
    yylval = t;
}

%}

DECDIGIT	[0-9]
UNSIGNEDNUMBER  (((0x)[0-9A-Fa-f]+)|{DECDIGIT}+)
LETTER		[_a-zA-Z]
LETTERORDIGIT	({LETTER}|{DECDIGIT})
IDENT		{LETTER}({LETTERORDIGIT}*)
NEWLINE         \n
CR              \r
EOL             ({NEWLINE}|({CR}{NEWLINE}))
COMMENTSTART    #
COMMENT         {COMMENTSTART}.*
IGNORED         [ \t\v\f\r]

  /* states of the lexer */

%s INSTRUCTION
%s DATADECL

%%

{IGNORED}       { ; } /* do nothing */
{COMMENT}       { ; } /* ignore comments */
<INSTRUCTION>{EOL} { BEGIN INITIAL; return eolsym; }
<DATADECL>{EOL} { BEGIN INITIAL; return eolsym; }
{EOL}           { ; } /* ignore EOL outside of the above states */

ADD             { BEGIN INSTRUCTION; tok2ast(addopsym); return addopsym; }
SUB             { BEGIN INSTRUCTION; tok2ast(subopsym); return subopsym; }
AND             { BEGIN INSTRUCTION; tok2ast(andopsym); return andopsym; }
BOR             { BEGIN INSTRUCTION; tok2ast(boropsym); return boropsym; }
NOR             { BEGIN INSTRUCTION; tok2ast(noropsym); return noropsym; }
XOR             { BEGIN INSTRUCTION; tok2ast(xoropsym); return xoropsym; }
MUL             { BEGIN INSTRUCTION; tok2ast(mulopsym); return mulopsym; }
DIV             { BEGIN INSTRUCTION; tok2ast(divopsym); return divopsym; }
SLL             { BEGIN INSTRUCTION; tok2ast(sllopsym); return sllopsym; }
SRL             { BEGIN INSTRUCTION; tok2ast(srlopsym); return srlopsym; }
MFHI            { BEGIN INSTRUCTION; tok2ast(mfhiopsym); return mfhiopsym; }
MFLO            { BEGIN INSTRUCTION; tok2ast(mfloopsym); return mfloopsym; }
JR              { BEGIN INSTRUCTION; tok2ast(jropsym); return jropsym; }
ADDI            { BEGIN INSTRUCTION; tok2ast(addiopsym); return addiopsym; }
ANDI            { BEGIN INSTRUCTION; tok2ast(andiopsym); return andiopsym; }
BORI            { BEGIN INSTRUCTION; tok2ast(boriopsym); return boriopsym; }
XORI            { BEGIN INSTRUCTION; tok2ast(xoriopsym); return xoriopsym; }
BEQ             { BEGIN INSTRUCTION; tok2ast(beqopsym); return beqopsym; }
BGEZ            { BEGIN INSTRUCTION; tok2ast(bgezopsym); return bgezopsym; }
BLEZ            { BEGIN INSTRUCTION; tok2ast(blezopsym); return blezopsym; }
BGTZ            { BEGIN INSTRUCTION; tok2ast(bgtzopsym); return bgtzopsym; }
BLTZ            { BEGIN INSTRUCTION; tok2ast(bltzopsym); return bltzopsym; }
BNE             { BEGIN INSTRUCTION; tok2ast(bneopsym); return bneopsym; }
LBU             { BEGIN INSTRUCTION; tok2ast(lbuopsym); return lbuopsym; }
LW              { BEGIN INSTRUCTION; tok2ast(lwopsym); return lwopsym; }
SB              { BEGIN INSTRUCTION; tok2ast(sbopsym); return sbopsym; }
SW              { BEGIN INSTRUCTION; tok2ast(swopsym); return swopsym; }
JMP             { BEGIN INSTRUCTION; tok2ast(jmpopsym); return jmpopsym; }
JAL             { BEGIN INSTRUCTION; tok2ast(jalopsym); return jalopsym; }
EXIT            { BEGIN INSTRUCTION; tok2ast(exitopsym); return exitopsym; }
PSTR            { BEGIN INSTRUCTION; tok2ast(pstropsym); return pstropsym; }
PCH             { BEGIN INSTRUCTION; tok2ast(pchopsym); return pchopsym; }
RCH             { BEGIN INSTRUCTION; tok2ast(rchopsym); return rchopsym; }
STRA            { BEGIN INSTRUCTION; tok2ast(straopsym); return straopsym; }
NOTR            { BEGIN INSTRUCTION; tok2ast(notropsym); return notropsym; }

WORD            { BEGIN DATADECL; tok2ast(wordsym); return wordsym; }

\+              { tok2ast(plussym); return plussym; }
-               { tok2ast(minussym); return minussym; }
,               { return commasym; }

\.text          { tok2ast(dottextsym); return dottextsym; }
\.data          { tok2ast(dotdatasym); return dotdatasym; }
\.stack         { tok2ast(dotstacksym); return dotstacksym; }
\.end           { return dotendsym; }
\=              { tok2ast(equalsym); return equalsym; }
:               { return colonsym; }

{UNSIGNEDNUMBER} { unsigned int val;
                  int ssf_ret;
                  if (yyleng >= 2 && (strncmp(yytext, "0x", 2) == 0)) {
                      // hex literal
                      ssf_ret = sscanf(yytext+2, "%xt", &val);
                      if (ssf_ret != 1) {
                         bail_with_error("Unsigned hex literal (%s) could not be read by lexer!",
                         yytext);
                      }
                  } else {
                      ssf_ret = sscanf(yytext, "%ut", &val);
                      if (ssf_ret != 1) {
                         bail_with_error("Unsigned decimal literal (%s) could not be read by lexer!",
                         yytext);
                      }
                  }
                  unsignednum2ast(val);
                  return unsignednumsym; 
                }

${DECDIGIT}+    { reg2ast(yytext+1); return regsym; }
$at             { namedreg2ast(1,yytext); return regsym; }
$v0             { namedreg2ast(2,yytext); return regsym; }
$v1             { namedreg2ast(3,yytext); return regsym; }
$a0             { namedreg2ast(4,yytext); return regsym; }
$a1             { namedreg2ast(5,yytext); return regsym; }
$a2             { namedreg2ast(6,yytext); return regsym; }
$a3             { namedreg2ast(7,yytext); return regsym; }
$t0             { namedreg2ast(8,yytext); return regsym; }
$t1             { namedreg2ast(9,yytext); return regsym; }
$t2             { namedreg2ast(10,yytext); return regsym; }
$t3             { namedreg2ast(11,yytext); return regsym; }
$t4             { namedreg2ast(12,yytext); return regsym; }
$t5             { namedreg2ast(13,yytext); return regsym; }
$t6             { namedreg2ast(14,yytext); return regsym; }
$t7             { namedreg2ast(15,yytext); return regsym; }
$s0             { namedreg2ast(16,yytext); return regsym; }
$s1             { namedreg2ast(17,yytext); return regsym; }
$s2             { namedreg2ast(18,yytext); return regsym; }
$s3             { namedreg2ast(19,yytext); return regsym; }
$s4             { namedreg2ast(20,yytext); return regsym; }
$s5             { namedreg2ast(21,yytext); return regsym; }
$s6             { namedreg2ast(22,yytext); return regsym; }
$s7             { namedreg2ast(23,yytext); return regsym; }
$t8             { namedreg2ast(24,yytext); return regsym; }
$t9             { namedreg2ast(25,yytext); return regsym; }
$gp             { namedreg2ast(28,yytext); return regsym; }
$sp             { namedreg2ast(29,yytext); return regsym; }
$fp             { namedreg2ast(30,yytext); return regsym; }
$ra             { namedreg2ast(31,yytext); return regsym; }

{IDENT}         { ident2ast(yytext); return identsym; }

.   { char msgbuf[512];
      sprintf(msgbuf, "invalid character: '%c' ('\\0%o')", *yytext, *yytext);
      yyerror(lexer_filename(), msgbuf);
    }
%%

/* Requires: fname != NULL
 * Requires: fname is the name of a readable file
 * Initialize the lexer and start it reading from the given file. */
void asm_lexer_init(char *fname) {
   filename = fname;    
   yyin = fopen(fname, "r");
   if (yyin == NULL) {
       bail_with_error("Lexer cannot open %s", fname);
   }
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
    if (yyin != NULL) {
	int rc = fclose(yyin);
	if (rc == EOF) {
	    bail_with_error("Cannot close %s!", filename);
	}
    }
    filename = NULL;
    return 1;  /* no more input */
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg)
{
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s\n", filename, lexer_line(), msg);
}

/* On standard output:
 * Print a message about the file name of the lexer's input
 * and then print a heading for the lexer's output. */
extern void lexer_print_output_header();

/* Print information about the token t to stdout
 * followed by a newline */
extern void lexer_print_token(yytoken_kind_t t, unsigned int tline,
			      const char *txt);

/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);
	if (t == YYEOF) {
	    break;
	}
        if (t != eolsym) {
	    lexer_print_token(t, yylineno, yytext);
        } else {
	    lexer_print_token(t, yylineno, "\\n");
	}
    } while (t != YYEOF);
}
